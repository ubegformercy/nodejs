<!-- Enhanced Dashboard with Full CRUD Operations -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoostMon Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 24px;
            flex-wrap: wrap;
        }

        .view-toggle {
            display: flex;
            gap: 8px;
            background: #f0f0f0;
            padding: 6px;
            border-radius: 8px;
        }

        .view-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .header-role-filter {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 250px;
        }

        .header-role-filter label {
            font-size: 11px;
            font-weight: 700;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .header-role-filter select {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            font-size: 13px;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .header-role-filter select:hover {
            border-color: #667eea;
        }

        .header-role-filter select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .view-btn.active {
            background: white;
            color: #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
            flex: 1;
        }

        .header-logo {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: contain;
            background: #f5f5f5;
            padding: 4px;
        }

        .header-title {
            flex: 1;
        }

        .header-left h1 {
            color: #667eea;
            font-size: 28px;
            margin-bottom: 8px;
        }

        .header-left p {
            color: #666;
            font-size: 14px;
        }

        .status-badge {
            display: inline-block;
            background: #2ecc71;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-badge.offline {
            background: #e74c3c;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.15);
        }

        .card h2 {
            color: #667eea;
            font-size: 18px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-content {
            font-size: 32px;
            font-weight: 700;
            color: #764ba2;
            margin-bottom: 8px;
        }

        .card-label {
            color: #999;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .section {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .section h2 {
            color: #667eea;
            font-size: 20px;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #f0f0f0;
        }

        /* Add Entry Form Styles */
        .add-entry-form {
            background: #f9f9f9;
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        /* Apply same styling to form sections in tabbed view */
        .form-section {
            background: #f9f9f9;
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            align-items: end;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input,
        .form-group select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-note {
            grid-column: 1 / -1;
            font-size: 12px;
            color: #666;
            font-style: italic;
            margin-top: 10px;
            padding: 10px;
            background: #fff;
            border-left: 3px solid #667eea;
            border-radius: 4px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        .table-wrapper {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        th {
            background: #f9f9f9;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
        }

        tr:hover {
            background: #f9f9f9;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-active {
            background: #d4edda;
            color: #155724;
        }

        .badge-paused {
            background: #fff3cd;
            color: #856404;
        }

        .badge-expired {
            background: #f8d7da;
            color: #721c24;
        }

        .badge-bot {
            background: #e7f3ff;
            color: #004085;
        }

        .badge-user {
            background: #fff3e0;
            color: #e65100;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Editable Cell Styles */
        .editable-cell {
            cursor: pointer;
            position: relative;
            padding: 8px 12px !important;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .editable-cell:hover {
            background: #f0f0f0;
        }

        .edit-input {
            width: 100%;
            padding: 6px;
            border: 2px solid #667eea;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
        }

        .edit-input-field {
            padding: 8px !important;
            border: 2px solid #667eea !important;
            border-radius: 4px !important;
            font-size: 14px !important;
            font-family: inherit !important;
        }

        .edit-input-field:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
            border-color: #5568d3 !important;
        }

        .save-edit-btn,
        .cancel-edit-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.2s;
        }

        .save-edit-btn {
            background: #2ecc71;
            color: white;
        }

        .save-edit-btn:hover {
            background: #27ae60;
            transform: translateY(-1px);
        }

        .cancel-edit-btn {
            background: #e74c3c;
            color: white;
        }

        .cancel-edit-btn:hover {
            background: #c0392b;
            transform: translateY(-1px);
        }

        .edit-actions {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }

        .edit-actions button {
            flex: 1;
            padding: 4px 8px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }

        .edit-actions .save {
            background: #2ecc71;
            color: white;
        }

        .edit-actions .cancel {
            background: #e74c3c;
            color: white;
        }

        .action-column {
            text-align: right;
            white-space: nowrap;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .delete-btn {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .delete-btn:hover {
            background: #c0392b;
            transform: scale(1.1);
        }

        /* Autopurge Form Styles */
        .add-autopurge-form {
            background: #f9f9f9;
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .add-autopurge-form h3 {
            color: #667eea;
            margin-bottom: 16px;
            font-size: 16px;
        }

        .form-row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .form-row select,
        .form-row input {
            flex: 1;
            min-width: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
        }

        .form-row select:focus,
        .form-row input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-row button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-row button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .form-row button:active {
            transform: translateY(0);
        }

        .autopurge-table-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .modal-content h3 {
            margin-bottom: 16px;
            color: #333;
        }

        .modal-content p {
            margin-bottom: 24px;
            color: #666;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-buttons .confirm {
            background: #e74c3c;
            color: white;
        }

        .modal-buttons .confirm:hover {
            background: #c0392b;
        }

        .modal-buttons .cancel {
            background: #bdc3c7;
            color: white;
        }

        .modal-buttons .cancel:hover {
            background: #95a5a6;
        }

        /* Alert/Toast Styles */
        .alert {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 14px;
            animation: slideIn 0.3s ease-out;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .footer {
            text-align: center;
            color: white;
            padding: 20px;
            font-size: 12px;
        }

        .footer-note {
            font-size: 12px;
            color: #666;
            margin-top: 12px;
            padding: 12px;
            background: #f9f9f9;
            border-left: 3px solid #e74c3c;
            border-radius: 4px;
            text-align: left;
        }

        /* Debug Panel Styles */
        .debug-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            max-height: 400px;
            background: #1e1e1e;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .debug-panel-header {
            background: #667eea;
            color: white;
            padding: 8px 12px;
            font-weight: 600;
            border-radius: 6px 6px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-panel-toggle {
            cursor: pointer;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .debug-panel-logs {
            flex: 1;
            overflow-y: auto;
            padding: 8px 12px;
            color: #0f0;
            line-height: 1.4;
        }

        .debug-log {
            margin-bottom: 4px;
            word-break: break-all;
            white-space: pre-wrap;
            color: #0f0;
        }

        .debug-log-error,
        .debug-log.error {
            color: #ff6b6b;
        }

        .debug-log-warn,
        .debug-log.warn {
            color: #ffd93d;
        }

        .debug-log-log,
        .debug-log.log {
            color: #0f0;
        }

        .debug-log.info {
            color: #6bcf7f;
        }

        .debug-log.success {
            color: #51cf66;
        }

        .debug-log-time {
            color: #888;
            font-size: 10px;
        }

        @media (max-width: 768px) {
            header {
                flex-direction: column;
                text-align: center;
                gap: 16px;
            }

            .header-left {
                flex-direction: column;
                width: 100%;
            }

            .header-logo {
                width: 50px;
                height: 50px;
            }

            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .card-content {
                font-size: 24px;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }

            table {
                font-size: 12px;
            }

            td, th {
                padding: 8px;
            }

            .action-buttons {
                flex-direction: column;
            }
        }

        .role-selector-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            border-left: 4px solid #667eea;
        }

        .role-selector-container {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .role-selector-container label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .role-selector-container select {
            padding: 10px 16px;
            border: 2px solid #667eea;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            cursor: pointer;
            min-width: 250px;
        }

        .role-selector-container select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
            border-color: #5568d3;
        }

        .role-info {
            padding: 8px 16px;
            background: #f0f4ff;
            border-radius: 6px;
            color: #667eea;
            font-weight: 600;
            font-size: 13px;
        }

        .table-controls {
            background: white;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .control-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group input,
        .control-group select {
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            cursor: pointer;
        }

        .control-group input {
            cursor: text;
            flex: 1;
            min-width: 300px;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .placeholder-state {
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Searchable Dropdown Styles */
        .searchable-dropdown-wrapper {
            position: relative;
            width: 100%;
        }

        .dropdown-search-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
        }

        .dropdown-search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .dropdown-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .dropdown-list.active {
            display: block;
        }

        .dropdown-item {
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .dropdown-item:hover {
            background: #f5f5f5;
        }

        .dropdown-item.selected {
            background: #e8f0ff;
            border-left: 3px solid #667eea;
            padding-left: 9px;
        }

        .dropdown-item.manual-id-option {
            font-weight: 600;
            background: #fff9e6 !important;
        }

        .dropdown-item.manual-id-option:hover {
            background: #fff3cd !important;
        }

        .dropdown-item-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
        }

        .dropdown-item-type {
            font-size: 12px;
            margin-left: auto;
            color: #999;
        }

        .type-badge {
            background: #e7f3ff;
            color: #004085;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
        }

        .type-badge.online {
            background: #d4edda;
            color: #155724;
        }

        .type-badge.idle {
            background: #fff3cd;
            color: #856404;
        }

        .type-badge.dnd {
            background: #f8d7da;
            color: #721c24;
        }

        .type-badge.offline {
            background: #e2e3e5;
            color: #383d41;
        }

        .dropdown-no-results {
            padding: 20px;
            text-align: center;
            color: #999;
            font-size: 14px;
        }

        .dropdown-selected-value {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            min-height: 40px;
        }

        .dropdown-selected-value.placeholder {
            color: #999;
        }

        /* TABBED VIEW STYLES */
        .tabs-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin-bottom: 30px;
            display: none;
        }

        .tabs-container.active {
            display: block;
        }

        .tabs-header {
            display: flex;
            border-bottom: 2px solid #f0f0f0;
            background: #f9f9f9;
        }

        .tab-button {
            flex: 1;
            padding: 20px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            color: #666;
            transition: all 0.3s ease;
            position: relative;
            text-align: center;
        }

        .tab-button:hover {
            background: #f5f5f5;
            color: #333;
        }

        .tab-button.active {
            color: #667eea;
            background: white;
        }

        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #667eea;
        }

        .tabs-content {
            padding: 30px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Grid View Container */
        .grid-view {
            display: block;
        }

        .grid-view.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-left">
                <img src="/images/boostmon.png" alt="BoostMon Logo" class="header-logo">
                <div class="header-title">
                    <h1>BoostMon Dashboard</h1>
                    <p>Your Server Boost Monitor</p>
                </div>
            </div>
            <div style="display: flex; flex-direction: column; gap: 12px; align-items: flex-start;">
                <div class="view-toggle">
                    <button class="view-btn active" onclick="switchViewMode('grid')">üìà Grid View</button>
                    <button class="view-btn" onclick="switchViewMode('tabbed')">üìä Tabbed View</button>
                </div>
                <div class="header-role-filter">
                    <label for="headerRoleFilter">üîç Filter by Role:</label>
                    <select id="headerRoleFilter" onchange="onHeaderRoleSelected()">
                        <option value="">-- Select a Role --</option>
                    </select>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 16px;">
                <div class="status-badge" id="statusBadge">Loading...</div>
                <a href="/auth/logout" style="padding: 8px 16px; background: #f0f0f0; color: #333; text-decoration: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">Logout</a>
            </div>
        </header>

        <!-- ERROR MESSAGE -->
        <div id="guildIdError" style="display: none; background: #fee; border: 2px solid #f88; border-radius: 8px; padding: 20px; margin: 20px 0; color: #333;">
            <h3 style="color: #f44; margin-top: 0;">‚ö†Ô∏è Guild ID Not Found</h3>
            <p>The dashboard couldn't find a guild ID. This usually means:</p>
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li>You accessed the dashboard directly without selecting a server first</li>
                <li>Your session expired or was cleared</li>
            </ul>
            <p><strong>To fix this, do one of the following:</strong></p>
            <ol style="margin: 10px 0; padding-left: 20px;">
                <li><a href="/guild-select.html" style="color: #667eea; font-weight: bold;">Go to Server Selection</a> - Select your server from the list</li>
                <li><strong>OR</strong> Add the guild ID to the URL manually:<br/>
                    <code style="background: #f5f5f5; padding: 8px; border-radius: 4px; display: inline-block; margin: 10px 0;">http://localhost:3000/dashboard.html?guild=YOUR_GUILD_ID</code>
                </li>
            </ol>
            <p style="font-size: 12px; color: #999; margin-bottom: 0;">Current URL: <code style="background: #f5f5f5; padding: 4px; border-radius: 2px;" id="currentUrlDisplay"></code></p>
        </div>

        <!-- STATS GRID (Always visible) -->
        <div class="dashboard-grid" id="statsGrid">
            <div class="card">
                <h2>üìä Active Timers: <span id="activeTimers">0</span></h2>
            </div>
            <div class="card">
                <h2>‚è∞ Scheduled Reports: <span id="scheduledReports">0</span></h2>
            </div>
            <div class="card">
                <h2>üóëÔ∏è Auto-Purge Settings: <span id="autopurgeCount">0</span></h2>
            </div>
        </div>

        <!-- GRID VIEW -->
        <div class="grid-view">

        <div class="section" id="timersSection">
            <h2>‚è±Ô∏è Active Timers</h2>

            <!-- Add Entry Form (Only shown after role is selected) -->
            <div class="add-entry-form" id="addEntryForm" style="display: none;">
                <h3 style="color: #667eea; margin-bottom: 16px; font-size: 16px; display: flex; align-items: center; gap: 8px; cursor: pointer;" onclick="toggleAddTimerForm()">
                    <span>‚ûï</span>
                    <span>Add New Timer Entry</span>
                </h3>
                <div class="form-grid" style="display: none;">
                    <div class="form-group">
                        <label for="newUserSearch" title="Can't find the user? Paste their Discord ID (18-20 digit number) or enter their username, then press Enter to search Discord.">
                            Select User <span style="color: #999; font-size: 12px;">(or enter Discord ID)</span>
                            <span id="memberCountBadge" style="margin-left: 10px; padding: 2px 8px; background: #e8f4f8; border-radius: 12px; font-size: 11px; color: #0066cc; display: none;">
                                üìä <span id="memberCount">0</span> members cached
                            </span>
                        </label>
                        <div class="searchable-dropdown-wrapper">
                            <input type="text" id="newUserSearch" class="dropdown-search-input" placeholder="üîç Search users or paste Discord ID..." autocomplete="off">
                            <div class="dropdown-list" id="newUserList"></div>
                            <input type="hidden" id="newUser" required>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="newMinutes">Minutes</label>
                        <input type="number" id="newMinutes" placeholder="30" min="1" required>
                    </div>
                    <div class="form-group">
                        <label for="newChannel">Select Warning Channel (Optional)</label>
                        <select id="newChannel">
                            <option value="">-- Select Warning Channel --</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <button class="btn btn-primary" onclick="addNewTimer()" style="margin-top: 24px;">‚ûï Add Entry</button>
                    </div>
                </div>
                <div class="form-note" style="display: none;">
                    ‚ÑπÔ∏è If no warning channel is selected, a DM will be sent to the user when their time is about to expire.
                </div>
            </div>

            <!-- Table Controls (Only shown after role is selected) -->
            <div class="table-controls" id="tableControls" style="display: none;">
                <div class="control-group">
                    <input type="text" id="userSearch" placeholder="Search users..." onkeyup="filterAndSortTimers()">
                    <select id="statusFilter" onchange="filterAndSortTimers()">
                        <option value="">All Status</option>
                        <option value="active">Active</option>
                        <option value="paused">Paused</option>
                        <option value="expired">Expired</option>
                    </select>
                    <select id="sortBy" onchange="filterAndSortTimers()">
                        <option value="expires-asc">Expires Soonest</option>
                        <option value="expires-desc">Expires Latest</option>
                        <option value="user-asc">User (A-Z)</option>
                        <option value="user-desc">User (Z-A)</option>
                    </select>
                </div>
            </div>

            <div id="timersList" class="placeholder-state">
                <div class="empty-state">
                    <div class="empty-state-icon">üëÜ</div>
                    <p>Select a role above to view timers</p>
                </div>
            </div>
        </div>

        <!-- SCHEDULED REPORTS SECTION -->
        <div class="section" id="reportsSection">
            <h2>üìã Scheduled Reports</h2>
            
            <!-- Add Report Form -->
            <div class="form-section" style="margin-bottom: 30px;">
                <h3 style="color: #667eea; margin-bottom: 16px; font-size: 16px;">‚ûï Add New Scheduled Report</h3>
                <form id="addReportForm" onsubmit="return handleAddReport(event)">
                    <div class="form-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 16px; align-items: flex-end;">
                        <div class="form-group">
                            <label for="reportRole">Role to Monitor *</label>
                            <select id="reportRole" required>
                                <option value="">Select a role...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="reportChannel">Post to Channel *</label>
                            <select id="reportChannel" required>
                                <option value="">Select a channel...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="reportInterval">Interval (minutes) *</label>
                            <input type="number" id="reportInterval" placeholder="60" min="1" required>
                        </div>
                        <div class="form-group">
                            <button type="submit" class="btn btn-primary">‚ûï Add Report</button>
                        </div>
                    </div>
                </form>
            </div>

            <!-- Reports Table -->
            <div class="table-wrapper">
                <table id="reportsTable">
                    <thead>
                        <tr>
                            <th>Role</th>
                            <th>Channel</th>
                            <th>Interval</th>
                            <th>Last Report</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="reportsTableBody">
                        <tr>
                            <td colspan="5" style="text-align: center; padding: 40px; color: #999;">
                                <div class="empty-state-icon">üìã</div>
                                <p>No scheduled reports yet</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- AUTO-PURGE SETTINGS SECTION -->
        <div class="section" id="autopurgeSection">
            <h2>üóëÔ∏è Auto-Purge Settings</h2>
            
            <!-- Add Autopurge Form -->
            <div class="form-section" style="margin-bottom: 30px;">
                <h3 style="color: #667eea; margin-bottom: 16px; font-size: 16px;">‚ûï Add New Auto-Purge Setting</h3>
                <form id="addAutopurgeForm" onsubmit="return handleAddAutopurge(event)">
                    <div class="form-row" style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                        <div class="form-group">
                            <label for="autopurgeChannel">Channel to Purge *</label>
                            <select id="autopurgeChannel" required>
                                <option value="">Select a channel...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="autopurgeType">Message Type *</label>
                            <select id="autopurgeType" required>
                                <option value="">Select message type...</option>
                                <option value="all">All Messages</option>
                                <option value="bots">Bot Messages Only</option>
                                <option value="embeds">Embeds Only</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-row" style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 16px; align-items: flex-end;">
                        <div class="form-group">
                            <label for="autopurgeLines">Messages to Purge *</label>
                            <input id="autopurgeLines" type="number" min="1" placeholder="10" required>
                        </div>
                        <div class="form-group">
                            <label for="autopurgeInterval">Interval (minutes) *</label>
                            <input id="autopurgeInterval" type="number" min="1" placeholder="30" required>
                        </div>
                        <div class="form-group">
                            <button type="submit" class="btn btn-primary">‚ûï Add Setting</button>
                        </div>
                    </div>
                </form>
            </div>

            <!-- Autopurge Table -->
            <div class="table-wrapper">
                <table id="autopurgeTable">
                    <thead>
                        <tr>
                            <th>Channel</th>
                            <th>Type</th>
                            <th>Messages to Purge</th>
                            <th>Interval</th>
                            <th>Last Purge</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="autopurgeTableBody">
                        <tr>
                            <td colspan="6" style="text-align: center; padding: 40px; color: #999;">
                                <div class="empty-state-icon">üóëÔ∏è</div>
                                <p>No auto-purge settings configured</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="footer">
            <p>BoostMon Dashboard ‚Ä¢ v<span id="versionDisplay">2.1.4</span> ‚Ä¢ Last Updated: <span id="lastUpdate">Never</span> ‚Ä¢ <a href="#" onclick="toggleDebugPanel(); return false;" style="color: inherit; text-decoration: none;">üêõ Debug</a></p>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal" id="confirmModal">
        <div class="modal-content">
            <h3>‚ö†Ô∏è Confirm Delete</h3>
            <p id="confirmMessage">Are you sure you want to delete this timer?</p>
            <div class="modal-buttons">
                <button class="confirm" onclick="confirmDelete()">Yes, Delete</button>
                <button class="cancel" onclick="cancelDelete()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Debug Panel (Hidden by Default) -->
    <div class="debug-panel" id="debugPanel" style="display: none;">
        <div class="debug-panel-header">
            <span>üêõ Debug Console</span>
            <button class="debug-panel-toggle" onclick="toggleDebugPanel()">Hide</button>
        </div>
        <div class="debug-panel-logs" id="debugLogs"></div>
    </div>

        <!-- TABBED VIEW -->
        <div class="tabs-container" id="tabbedView">
            <div class="tabs-header">
                <button class="tab-button active" data-tab="timers" onclick="switchTab('timers')">
                    ‚è±Ô∏è Active Timers
                </button>
                <button class="tab-button" data-tab="reports" onclick="switchTab('reports')">
                    üìã Scheduled Reports
                </button>
                <button class="tab-button" data-tab="autopurge" onclick="switchTab('autopurge')">
                    üóëÔ∏è Auto-Purge Settings
                </button>
            </div>

            <div class="tabs-content">
                <!-- TAB 1: ACTIVE TIMERS -->
                <div class="tab-panel active" id="timers-tab">

                    <!-- ADD NEW TIMER (Hidden until role selected) -->
                    <div class="form-section" id="addTimerSectionTab" style="display: none; margin-bottom: 20px;">
                        <h3 style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 16px; color: #667eea;" onclick="toggleAddTimerFormTab()">
                            <span id="addTimerTabToggleIcon">‚ûï</span>
                            <span>Add New Timer Entry</span>
                        </h3>
                        <form id="addEntryFormTab" class="add-timer-form" onsubmit="return handleAddTimerTab(event)" style="display: none;">
                            <!-- Row 1: User (wider) and Role (wider) -->
                            <div class="form-row" style="display: grid; grid-template-columns: 2fr 2fr; gap: 16px;">
                                <div class="form-group">
                                    <label for="newUserSearchTab">User *</label>
                                    <div class="dropdown-wrapper">
                                        <input type="text" id="newUserSearchTab" class="dropdown-search-input" placeholder="Search users or paste Discord ID..." autocomplete="off">
                                        <div class="dropdown-list" id="newUserListTab"></div>
                                        <input type="hidden" id="newUserTab" required>
                                    </div>
                                    <span id="memberCountBadgeTab" style="margin-top: 6px; padding: 4px 8px; background: #e8f4f8; border-radius: 4px; font-size: 11px; color: #0066cc; display: none;">
                                        üìä <span id="memberCountTab">0</span> members cached
                                    </span>
                                </div>
                                <div class="form-group">
                                    <label for="newRoleTab">Role *</label>
                                    <select id="newRoleTab" required>
                                        <option value="">Select a role...</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Row 2: Minutes (1/2 size) and Warning Channel (1/2 size) -->
                            <div class="form-row" style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                                <div class="form-group">
                                    <label for="newMinutesTab">Minutes *</label>
                                    <input type="number" id="newMinutesTab" placeholder="30" min="1" required>
                                </div>
                                <div class="form-group">
                                    <label for="newChannelTab">Warning Channel (Optional)</label>
                                    <select id="newChannelTab">
                                        <option value="">DM warnings</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Form Actions -->
                            <div class="form-actions" style="margin-top: 16px;">
                                <button type="submit" class="btn btn-primary">‚ûï Add Timer</button>
                                <button type="reset" class="btn btn-secondary">Clear</button>
                            </div>

                            <!-- Info Note -->
                            <div class="form-note" style="margin-top: 16px; padding: 12px; background: #e8f4f8; border-left: 4px solid #0066cc; border-radius: 4px; font-size: 13px; color: #0066cc;">
                                ‚ÑπÔ∏è If no warning channel is selected, a DM will be sent to the user when their time is about to expire.
                            </div>
                        </form>
                    </div>

                    <!-- FILTERS & SEARCH -->
                    <div class="form-section" style="margin-bottom: 20px;">
                        <div class="form-row">
                            <div class="form-group">
                                <label for="userSearchTab">Search</label>
                                <input type="text" id="userSearchTab" placeholder="Search users..." onkeyup="filterAndSortTimersTab()">
                            </div>
                            <div class="form-group">
                                <label for="statusFilterTab">Filter by Status</label>
                                <select id="statusFilterTab" onchange="filterAndSortTimersTab()">
                                    <option value="">All Statuses</option>
                                    <option value="active">Active</option>
                                    <option value="paused">Paused</option>
                                    <option value="expired">Expired</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="sortByTab">Sort By</label>
                                <select id="sortByTab" onchange="filterAndSortTimersTab()">
                                    <option value="expires-asc">Expires Soon (Ascending)</option>
                                    <option value="expires-desc">Expires Last (Descending)</option>
                                    <option value="user-asc">Username (A to Z)</option>
                                    <option value="user-desc">Username (Z to A)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- TIMERS TABLE -->
                    <div class="table-wrapper">
                        <table id="timersTableTab">
                            <thead>
                                <tr>
                                    <th>User</th>
                                    <th>Role</th>
                                    <th>Time Remaining</th>
                                    <th>Expires</th>
                                    <th>Status</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="timersListTab">
                                <tr><td colspan="6" class="placeholder-state">No timers yet</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- TAB 2: SCHEDULED REPORTS -->
                <div class="tab-panel" id="reports-tab">
                    <div class="form-section">
                        <h3>‚ûï Add New Scheduled Report</h3>
                        <form id="addReportFormTab" onsubmit="return handleAddReportTab(event)">
                            <div class="form-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 16px; align-items: flex-end;">
                                <div class="form-group">
                                    <label for="reportRoleTab">Role to Monitor</label>
                                    <select id="reportRoleTab" required>
                                        <option value="">Select a role...</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="reportChannelTab">Post to Channel</label>
                                    <select id="reportChannelTab" required>
                                        <option value="">Select a channel...</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="reportIntervalTab">Interval (minutes)</label>
                                    <input type="number" id="reportIntervalTab" placeholder="60" min="1" required>
                                </div>
                                <div class="form-group">
                                    <button type="submit" class="btn btn-primary">‚ûï Add Report</button>
                                </div>
                            </div>
                        </form>
                    </div>

                    <!-- REPORTS TABLE -->
                    <div class="table-wrapper">
                        <table id="reportsTableTab">
                            <thead>
                                <tr>
                                    <th>Role</th>
                                    <th>Channel</th>
                                    <th>Interval</th>
                                    <th>Last Report</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="reportsTableBodyTab">
                                <tr><td colspan="5" class="placeholder-state">No scheduled reports yet</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- TAB 3: AUTO-PURGE SETTINGS -->
                <div class="tab-panel" id="autopurge-tab">
                    <div class="form-section">
                        <h3>‚ûï Add Auto-Purge Setting</h3>
                        <form id="autopurgeFormTab" onsubmit="return handleAddAutopurgeTab(event)">
                            <div class="form-row" style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                                <div class="form-group">
                                    <label for="autopurgeChannelTab">Channel to Purge</label>
                                    <select id="autopurgeChannelTab" required>
                                        <option value="">Select a channel...</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="autopurgeTypeTab">Message Type</label>
                                    <select id="autopurgeTypeTab" required>
                                        <option value="">Select message type...</option>
                                        <option value="bot">Bot messages only</option>
                                        <option value="user">User messages only</option>
                                        <option value="both">Both bot and user</option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-row" style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 16px; align-items: flex-end;">
                                <div class="form-group">
                                    <label for="autopurgeLinesTab">Messages to Delete</label>
                                    <input id="autopurgeLinesTab" type="number" min="1" placeholder="10" required>
                                </div>
                                <div class="form-group">
                                    <label for="autopurgeIntervalTab">Interval (minutes)</label>
                                    <input id="autopurgeIntervalTab" type="number" min="1" placeholder="30" required>
                                </div>
                                <div class="form-group">
                                    <button type="submit" class="btn btn-primary">‚ûï Add Setting</button>
                                </div>
                            </div>
                        </form>
                    </div>

                    <!-- AUTOPURGE TABLE -->
                    <div class="table-wrapper">
                        <table id="autopurgeTableTab">
                            <thead>
                                <tr>
                                    <th>Channel</th>
                                    <th>Type</th>
                                    <th>Messages</th>
                                    <th>Interval</th>
                                    <th>Last Purge</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="autopurgeTableBodyTab">
                                <tr><td colspan="6" class="placeholder-state">No auto-purge settings yet</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <!-- TABBED VIEW FOOTER -->
            <div class="footer" style="margin-top: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px; padding-bottom: 20px;">
                <p style="margin: 0;">BoostMon Dashboard ‚Ä¢ v<span id="versionDisplayTab">2.1.4</span> ‚Ä¢ Last Updated: <span id="lastUpdateTab">Never</span> ‚Ä¢ <a href="#" onclick="toggleDebugPanel(); return false;" style="color: inherit; text-decoration: none;">üêõ Debug</a></p>
            </div>
        </div>
        </div>
        </div>

    <script>
        let allTimers = [];
        let selectedRoleId = null;
        let allRoles = [];
        let filteredTimers = [];
        let debugLogs = [];
        let allUsers = []; // Store all users for searchable dropdown
        let currentView = 'grid'; // Track current view mode

        // View Switching Functions
        function switchViewMode(mode) {
            currentView = mode;
            const gridView = document.querySelector('.grid-view');
            const tabbedView = document.getElementById('tabbedView');
            const buttons = document.querySelectorAll('.view-btn');
            
            if (mode === 'grid') {
                gridView.style.display = 'block';
                tabbedView.style.display = 'none';
                buttons[0].classList.add('active');
                buttons[1].classList.remove('active');
            } else {
                gridView.style.display = 'none';
                tabbedView.style.display = 'block';
                buttons[0].classList.remove('active');
                buttons[1].classList.add('active');
            }
        }

        function switchTab(tabName) {
            // Hide all tabs
            const panels = document.querySelectorAll('.tab-panel');
            panels.forEach(panel => panel.classList.remove('active'));
            
            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.tabs-header .tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Show selected tab
            const selectedPanel = document.getElementById(tabName + '-tab');
            if (selectedPanel) {
                selectedPanel.classList.add('active');
            }
            
            // Activate selected button
            const selectedButton = document.querySelector(`[data-tab="${tabName}"]`);
            if (selectedButton) {
                selectedButton.classList.add('active');
            }
        }

        // Searchable Dropdown Management
        function initSearchableDropdown() {
            const searchInput = document.getElementById('newUserSearch');
            const dropdown = document.getElementById('newUserList');
            const hiddenInput = document.getElementById('newUser');
            
            if (!searchInput || !dropdown) return;
            
            // Show dropdown on click
            searchInput.addEventListener('click', () => {
                renderDropdownOptions(allUsers, '');
                dropdown.classList.add('active');
            });
            
            // Filter on input
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase().trim();
                renderDropdownOptions(allUsers, query);
                
                // Check if query looks like a Discord ID (18-20 digits)
                if (/^\d{18,20}$/.test(query)) {
                    // Add manual ID option at the top
                    const dropdown = document.getElementById('newUserList');
                    const firstChild = dropdown.firstChild;
                    if (firstChild && !firstChild.classList.contains('manual-id-option')) {
                        const manualOption = document.createElement('div');
                        manualOption.className = 'dropdown-item manual-id-option';
                        manualOption.style.backgroundColor = '#e8f0ff';
                        manualOption.style.borderLeft = '3px solid #667eea';
                        manualOption.style.paddingLeft = '9px';
                        manualOption.innerHTML = `<span>‚ûï Add user by ID</span><span class="dropdown-item-type"><span class="type-badge" style="background: #fff3cd; color: #856404;">Manual ID</span></span>`;
                        manualOption.onclick = () => selectUser(query, query, `User #${query}`);
                        dropdown.insertBefore(manualOption, firstChild);
                    }
                }
                
                if (allUsers.length > 0 || /^\d{18,20}$/.test(query)) {
                    dropdown.classList.add('active');
                }
            });
            
            // Handle Enter key for Advanced Search
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performAdvancedSearch(searchInput.value.trim());
                }
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.searchable-dropdown-wrapper')) {
                    dropdown.classList.remove('active');
                }
            });
        }
        
        async function performAdvancedSearch(query) {
            if (!query) return;
            
            const searchInput = document.getElementById('newUserSearch');
            const dropdown = document.getElementById('newUserList');
            
            try {
                // Show searching indicator
                dropdown.innerHTML = '<div class="dropdown-item" style="text-align: center; color: #999;">üîç Searching...</div>';
                dropdown.classList.add('active');
                
                // Use the global guildId variable
                if (!guildId) {
                    dropdown.innerHTML = '<div class="dropdown-item" style="color: #e74c3c; padding: 12px;">‚ùå Guild ID not available - please reload the page</div>';
                    return;
                }
                
                console.log('[Advanced Search] Query:', query, 'GuildId:', guildId);
                
                const response = await fetch('/api/search-user', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query, guildId })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    dropdown.innerHTML = `<div class="dropdown-item" style="color: #e74c3c; padding: 12px;">‚ùå ${error.error || 'User not found'}</div>`;
                    return;
                }
                
                const user = await response.json();
                
                // Check if user is already in the list
                const isInList = allUsers.some(u => u.id === user.id);
                
                let statusEmoji = {
                    'online': 'üü¢',
                    'idle': 'üü°',
                    'dnd': 'üî¥',
                    'offline': '‚ö™'
                }[user.status] || '‚ö™';
                
                let sourceLabel = user.source === 'database' ? ' (from timers)' : user.source === 'discord-fetch' ? ' (found on Discord)' : '';
                let notInGuildLabel = user.notInGuild ? ' ‚ö†Ô∏è Not in guild' : '';
                
                // Format display: [username] displayName
                const username = user.name || user.id;
                const displayName = user.displayName || user.name || user.id;
                let userDisplay = username;
                if (displayName !== username && displayName) {
                    userDisplay = `[${username}] ${displayName}`;
                }
                
                dropdown.innerHTML = `
                    <div class="dropdown-item" onclick="selectUser('${user.id}', '${username.replace(/'/g, "\\'")}', '${displayName.replace(/'/g, "\\'")}')">
                        <span>${userDisplay}${sourceLabel}${notInGuildLabel}</span>
                        <span class="dropdown-item-type"><span class="type-badge">${statusEmoji} ${user.status || 'offline'}</span></span>
                    </div>
                `;
                
            } catch (err) {
                console.error('Advanced search error:', err);
                dropdown.innerHTML = '<div class="dropdown-item" style="color: #e74c3c; padding: 12px;">‚ùå Search failed - please try again</div>';
            }
        }
        
        function renderDropdownOptions(users, query) {
            const dropdown = document.getElementById('newUserList');
            const searchInput = document.getElementById('newUserSearch');
            
            if (!dropdown) return;
            
            // Deduplicate users by ID before filtering
            const userMap = new Map();
            users.forEach(user => {
                if (!userMap.has(user.id)) {
                    userMap.set(user.id, user);
                }
            });
            const uniqueUsers = Array.from(userMap.values());
            
            // Filter users based on query
            const filtered = uniqueUsers.filter(user => {
                const displayName = (user.displayName || user.name || '').toLowerCase();
                const username = (user.name || '').toLowerCase();
                const userId = user.id.toLowerCase();
                return displayName.includes(query) || username.includes(query) || userId.includes(query);
            });
            
            if (filtered.length === 0) {
                // Check if query is a valid Discord ID
                if (/^\d{18,20}$/.test(query.trim())) {
                    dropdown.innerHTML = ''; // Will show manual ID option separately
                } else {
                    dropdown.innerHTML = '<div class="dropdown-no-results">No users found</div>';
                }
                return;
            }
            
            dropdown.innerHTML = filtered.map(user => {
                const statusEmoji = {
                    'online': 'üü¢',
                    'idle': 'üü°',
                    'dnd': 'üî¥',
                    'offline': '‚ö™'
                }[user.status] || '‚ö™';
                
                const sourceLabel = user.source === 'database' ? ' (from timers)' : '';
                const typeBadge = `<span class="type-badge ${user.status || 'offline'}">${statusEmoji} ${user.status || 'offline'}</span>`;
                
                // Show both username and display name
                const username = user.name || user.id;
                const displayName = user.displayName || user.name || user.id;
                let userDisplay = username;
                
                // If display name is different from username, show both
                if (displayName !== username && displayName) {
                    userDisplay = `[${username}] ${displayName}`;
                }
                
                return `
                    <div class="dropdown-item" onclick="selectUser('${user.id}', '${username.replace(/'/g, "\\'")}', '${displayName.replace(/'/g, "\\'")}')">
                        <span>${userDisplay}${sourceLabel}</span>
                        <span class="dropdown-item-type">${typeBadge}</span>
                    </div>
                `;
            }).join('');
        }
        
        function selectUser(userId, username, displayName) {
            const searchInput = document.getElementById('newUserSearch');
            const hiddenInput = document.getElementById('newUser');
            const dropdown = document.getElementById('newUserList');
            
            if (hiddenInput) hiddenInput.value = userId;
            if (searchInput) {
                // If it's a manual ID, show just the ID
                if (/^\d{18,20}$/.test(userId)) {
                    searchInput.value = `ID: ${userId}`;
                } else {
                    // Show both username and display name if they're different
                    if (displayName && displayName !== username) {
                        searchInput.value = `[${username}] ${displayName}`;
                    } else {
                        searchInput.value = username || displayName;
                    }
                }
            }
            dropdown.classList.remove('active');
        }

        // Debug Logging System
        function addDebugLog(message, type = 'info') {
            const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
            const logEntry = { message, type, time };
            debugLogs.push(logEntry);
            
            // Keep only last 50 logs
            if (debugLogs.length > 50) {
                debugLogs.shift();
            }
            
            // Update UI
            const logsContainer = document.getElementById('debugLogs');
            if (logsContainer) {
                const logEl = document.createElement('div');
                logEl.className = `debug-log ${type}`;
                logEl.innerHTML = `<span class="debug-log-time">[${time}]</span> ${message}`;
                logsContainer.appendChild(logEl);
                logsContainer.scrollTop = logsContainer.scrollHeight;
            }
            
            // Also log to console for visibility
            const consoleStyle = type === 'error' ? 'color: red; font-weight: bold;' : 
                                type === 'warn' ? 'color: orange; font-weight: bold;' :
                                type === 'success' ? 'color: green; font-weight: bold;' :
                                'color: cyan;';
            console.log(`%c[${type.toUpperCase()}] ${message}`, consoleStyle);
        }

        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'flex';
            } else {
                panel.style.display = 'none';
            }
        }

        // ========== DEBUG CONSOLE IMPLEMENTATION ==========
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;

        // Function to log to the debug panel
        function logToDebugPanel(message, type = 'log') {
            const debugLogs = document.getElementById('debugLogs');
            if (!debugLogs) return;

            const logEntry = document.createElement('div');
            logEntry.className = `debug-log debug-log-${type}`;
            
            // Format timestamp
            const now = new Date();
            const timeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            
            // Format message
            let displayMessage = message;
            if (typeof message === 'object') {
                try {
                    displayMessage = JSON.stringify(message, null, 2);
                } catch (e) {
                    displayMessage = String(message);
                }
            }
            
            logEntry.textContent = `[${timeStr}] ${displayMessage}`;
            debugLogs.appendChild(logEntry);
            debugLogs.scrollTop = debugLogs.scrollHeight; // Auto-scroll to bottom
        }

        // Intercept console methods
        console.log = function(...args) {
            originalLog.apply(console, args);
            args.forEach(arg => logToDebugPanel(arg, 'log'));
        };

        console.error = function(...args) {
            originalError.apply(console, args);
            args.forEach(arg => logToDebugPanel(arg, 'error'));
        };

        console.warn = function(...args) {
            originalWarn.apply(console, args);
            args.forEach(arg => logToDebugPanel(arg, 'warn'));
        };

        // Toggle debug panel visibility
        function toggleDebugPanel() {
            const debugPanel = document.getElementById('debugPanel');
            if (debugPanel) {
                const isHidden = debugPanel.style.display === 'none';
                debugPanel.style.display = isHidden ? 'block' : 'none';
                
                // Update button text
                const button = debugPanel.querySelector('.debug-panel-toggle');
                if (button) {
                    button.textContent = isHidden ? 'Hide' : 'Show';
                }
                
                // Save preference to sessionStorage
                sessionStorage.setItem('debugPanelOpen', isHidden);
            }
        }

        // Open debug panel by default
        function openDebugPanelByDefault() {
            const debugPanel = document.getElementById('debugPanel');
            if (debugPanel) {
                debugPanel.style.display = 'block';
                const button = debugPanel.querySelector('.debug-panel-toggle');
                if (button) {
                    button.textContent = 'Hide';
                }
                sessionStorage.setItem('debugPanelOpen', true);
                console.log('üêõ Debug Console Opened');
            }
        }

        // ========== END DEBUG CONSOLE IMPLEMENTATION ==========

        // Check authentication on page load
        async function checkAuth() {
            try {
                const response = await fetch('/auth/user', {
                    credentials: 'include'
                });
                if (!response.ok) {
                    window.location.href = '/login.html';
                    return false;
                }
                return true;
            } catch (err) {
                window.location.href = '/login.html';
                return false;
            }
        }

        // Get guild from URL query parameter
        function getGuildId() {
            // First try URL parameter
            const params = new URLSearchParams(window.location.search);
            const urlGuildId = params.get('guild');
            
            // If found in URL, save to sessionStorage and return
            if (urlGuildId) {
                sessionStorage.setItem('guildId', urlGuildId);
                return urlGuildId;
            }
            
            // Otherwise try sessionStorage
            return sessionStorage.getItem('guildId');
        }

        function navigateToDashboard2() {
            const guildId = getGuildId();
            if (!guildId) {
                showAlert('Guild ID not found. Please reload the page.', 'error');
                return;
            }
            // Navigation will happen without URL param since sessionStorage is set
            window.location.href = '/dashboard2.html';
        }

        function toggleAddTimerForm() {
            const form = document.getElementById('addEntryForm');
            const content = form.querySelector('div.form-grid');
            
            if (content.style.display === 'none') {
                content.style.display = 'grid';
            } else {
                content.style.display = 'none';
            }
        }

        function showAlert(message, type = 'success') {
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            
            const container = document.querySelector('.container');
            container.insertBefore(alert, container.firstChild);
            
            setTimeout(() => {
                alert.remove();
            }, 4000);
        }

        // Show a confirmation dialog for delete operations
        function showConfirmDialog(title, message, onConfirm, onCancel) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;

            // Create modal dialog
            const modal = document.createElement('div');
            modal.className = 'modal-dialog';
            modal.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 30px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
                text-align: center;
            `;

            // Warning icon
            const warning = document.createElement('div');
            warning.style.cssText = `
                font-size: 48px;
                margin-bottom: 20px;
            `;
            warning.textContent = '‚ö†Ô∏è';

            // Title
            const titleEl = document.createElement('h3');
            titleEl.style.cssText = `
                margin: 0 0 10px 0;
                font-size: 20px;
                color: #333;
            `;
            titleEl.textContent = title;

            // Message
            const messageEl = document.createElement('p');
            messageEl.style.cssText = `
                margin: 10px 0 25px 0;
                font-size: 14px;
                color: #666;
                line-height: 1.5;
            `;
            messageEl.textContent = message;

            // Button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                gap: 10px;
                justify-content: center;
            `;

            // Confirm button
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'Yes, Delete';
            confirmBtn.style.cssText = `
                background-color: #ef4444;
                color: white;
                border: none;
                padding: 10px 30px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 14px;
                transition: background-color 0.2s;
            `;
            confirmBtn.onmouseover = () => confirmBtn.style.backgroundColor = '#dc2626';
            confirmBtn.onmouseout = () => confirmBtn.style.backgroundColor = '#ef4444';
            confirmBtn.onclick = () => {
                overlay.remove();
                if (onConfirm) onConfirm();
            };

            // Cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = `
                background-color: #9ca3af;
                color: white;
                border: none;
                padding: 10px 30px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 14px;
                transition: background-color 0.2s;
            `;
            cancelBtn.onmouseover = () => cancelBtn.style.backgroundColor = '#6b7280';
            cancelBtn.onmouseout = () => cancelBtn.style.backgroundColor = '#9ca3af';
            cancelBtn.onclick = () => {
                overlay.remove();
                if (onCancel) onCancel();
            };

            buttonContainer.appendChild(confirmBtn);
            buttonContainer.appendChild(cancelBtn);

            modal.appendChild(warning);
            modal.appendChild(titleEl);
            modal.appendChild(messageEl);
            modal.appendChild(buttonContainer);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            // Close when clicking outside modal
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                    if (onCancel) onCancel();
                }
            });
        }

        async function loadDashboard() {
            try {
                guildId = getGuildId();
                console.log('[Dashboard] Attempting to load. guildId from getGuildId():', guildId);
                console.log('[Dashboard] URL params:', window.location.search);
                console.log('[Dashboard] sessionStorage.guildId:', sessionStorage.getItem('guildId'));
                
                if (!guildId) {
                    console.warn('[Dashboard] No guildId found, showing error message');
                    const guildIdErrorEl = document.getElementById('guildIdError');
                    const currentUrlDisplayEl = document.getElementById('currentUrlDisplay');
                    const statusBadgeEl = document.getElementById('statusBadge');
                    
                    if (guildIdErrorEl) guildIdErrorEl.style.display = 'block';
                    if (currentUrlDisplayEl) currentUrlDisplayEl.textContent = window.location.href;
                    if (statusBadgeEl) {
                        statusBadgeEl.textContent = 'NO GUILD';
                        statusBadgeEl.classList.add('offline');
                    }
                    return;
                }
                
                // Hide error if guild ID is present
                const guildIdErrorEl2 = document.getElementById('guildIdError');
                if (guildIdErrorEl2) guildIdErrorEl2.style.display = 'none';
                
                const url = `/api/dashboard?guildId=${guildId}`;
                console.log('[Dashboard] Fetching:', url);
                const response = await fetch(url, {
                    credentials: 'include'
                });
                
                console.log('[Dashboard] API response status:', response.status, 'URL:', url);
                
                if (response.status === 403 || response.status === 401) {
                    console.warn('Access denied to guild:', guildId);
                    window.location.href = '/login.html';
                    return;
                }
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[Dashboard] API error response:', response.status, errorText);
                    throw new Error(`Failed to load dashboard data: ${response.status} ${errorText}`);
                }
                
                const data = await response.json();
                console.log('[Dashboard] Data loaded successfully, timers:', data.timers?.length || 0);
                console.log('[Dashboard] Reports in response:', data.reports?.length || 0, 'reports:', data.reports);
                console.log('[Dashboard] Autopurge in response:', data.autopurge?.length || 0, 'autopurge:', data.autopurge);
                console.log('[Dashboard] ========== CALLING updateDashboard() ==========');
                updateDashboard(data);
                console.log('[Dashboard] ========== updateDashboard() COMPLETED SUCCESSFULLY ==========');
            } catch (err) {
                console.error('[Dashboard] CAUGHT ERROR:', err);
                console.error('[Dashboard] Error details:', {
                    message: err.message,
                    stack: err.stack,
                    guildId: guildId,
                    url: `/api/dashboard?guildId=${guildId}`
                });
                console.error('[Dashboard] Setting ERROR badge');
                const statusBadgeErrEl = document.getElementById('statusBadge');
                if (statusBadgeErrEl) {
                    statusBadgeErrEl.textContent = 'ERROR';
                    statusBadgeErrEl.classList.add('offline');
                    console.error('[Dashboard] ERROR badge set:', statusBadgeErrEl.textContent);
                }
            }
        }

        // Delete a scheduled report
        async function deleteReport(reportId) {
            // Get report info for the confirmation message
            const reportRow = document.querySelector(`button[onclick="deleteReport(${reportId})"]`)?.closest('tr');
            const roleCell = reportRow?.cells[0]?.textContent || 'Unknown Role';
            const channelCell = reportRow?.cells[1]?.textContent || 'Unknown Channel';

            showConfirmDialog(
                'Confirm Delete',
                `Are you sure you want to delete the report for\n${roleCell} in ${channelCell}?`,
                async () => {
                    try {
                        const response = await fetch(`/api/report/delete?guildId=${guildId}`, {
                            method: 'DELETE',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ reportId })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.error || 'Failed to delete report');
                        }

                        showAlert('Report deleted successfully!', 'success');
                        await loadDashboard();
                    } catch (err) {
                        console.error('Error deleting report:', err);
                        showAlert(`Error: ${err.message}`, 'error');
                    }
                }
            );
        }

        // Delete an autopurge setting
        async function deleteAutopurgeSetting(channelId) {
            // Get channel info for the confirmation message
            const row = document.querySelector(`button[onclick="deleteAutopurgeSetting(${channelId})"]`)?.closest('tr');
            const channelCell = row?.cells[0]?.textContent || 'Unknown Channel';

            showConfirmDialog(
                'Confirm Delete',
                `Are you sure you want to delete the auto-purge setting for\n${channelCell}?`,
                async () => {
                    try {
                        console.log('[DEBUG] Deleting autopurge - channelId:', channelId, 'type:', typeof channelId, 'guildId:', guildId);
                        const response = await fetch(`/api/autopurge/delete?guildId=${guildId}`, {
                            method: 'DELETE',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ channelId })
                        });

                        console.log('[DEBUG] Response status:', response.status);
                        if (!response.ok) {
                            const error = await response.json();
                            console.log('[DEBUG] Error response:', error);
                            throw new Error(error.error || 'Failed to delete autopurge setting');
                        }

                        showAlert('Auto-purge setting deleted successfully!', 'success');
                        await loadDashboard();
                    } catch (err) {
                        console.error('Error deleting autopurge setting:', err);
                        showAlert(`Error: ${err.message}`, 'error');
                    }
                }
            );
        }

        function updateDashboard(data) {
            try {
                console.log('[Dashboard] ========== updateDashboard() CALLED ==========');
                console.log('[Dashboard] Data received:', typeof data, data ? 'not null' : 'null');
                
                if (!data) {
                    console.error('[Dashboard] ERROR: data is null or undefined!');
                    return;
                }
                
                console.log('[Dashboard] Data object keys:', Object.keys(data));
                
                const statusBadge = document.getElementById('statusBadge');
                if (!statusBadge) {
                    console.error('[Dashboard] ERROR: statusBadge element not found!');
                    return;
                }
                console.log('[Dashboard] statusBadge found, current text:', statusBadge.textContent);
                console.log('[Dashboard] Checking data.botStatus:', data.botStatus);
                
                if (data.botStatus === 'online') {
                    statusBadge.textContent = 'üü¢ ONLINE';
                    statusBadge.classList.remove('offline');
                    console.log('[Dashboard] ‚úÖ Set status to ONLINE');
                } else {
                    statusBadge.textContent = 'üî¥ OFFLINE';
                    statusBadge.classList.add('offline');
                    console.log('[Dashboard] ‚úÖ Set status to OFFLINE');
                }
                
                console.log('[Dashboard] statusBadge text AFTER status update:', statusBadge.textContent);
                
                console.log('[Dashboard] Updating stats...');
                const activeTimersEl = document.getElementById('activeTimers');
                const scheduledReportsEl = document.getElementById('scheduledReports');
                const autopurgeCountEl = document.getElementById('autopurgeCount');
                
                if (activeTimersEl) activeTimersEl.textContent = data.stats.activeTimers || 0;
                if (scheduledReportsEl) scheduledReportsEl.textContent = data.stats.scheduledReports || 0;
                if (autopurgeCountEl) autopurgeCountEl.textContent = data.stats.autopurgeSettings || 0;
                console.log('[Dashboard] Stats updated');

                console.log('[Dashboard] Setting allTimers array...');
                allTimers = data.timers || [];
                console.log('[Dashboard] allTimers set, count:', allTimers.length);
                
                console.log('[Dashboard] Extracting unique roles...');
                // Extract unique roles from timers
                const roleMap = new Map();
                allTimers.forEach(timer => {
                    if (!roleMap.has(timer.roleId)) {
                        roleMap.set(timer.roleId, timer.role);
                    }
                });
                
                allRoles = Array.from(roleMap.entries()).map(([id, name]) => ({ id, name }))
                    .sort((a, b) => a.name.localeCompare(b.name));
                console.log('[Dashboard] Roles extracted, count:', allRoles.length);
                
                console.log('[Dashboard] Populating role selector...');
                // Populate role selector (use headerRoleFilter for grid view)
                const roleSelect = document.getElementById('headerRoleFilter');
                let currentValue = null;  // Declare outside the if block
                
                if (roleSelect) {
                    currentValue = roleSelect.value;  // Assign the value
                    roleSelect.innerHTML = '<option value="">-- Select a Role --</option>';
                    
                    allRoles.forEach(role => {
                        const option = document.createElement('option');
                        option.value = role.id;
                        option.textContent = role.name;
                        roleSelect.appendChild(option);
                    });
                    
                    roleSelect.value = currentValue;
                } else {
                    console.warn('[Dashboard] Role filter element not found');
                }
                
                console.log('[Dashboard] Role selector populated');
                
                // Restore previous selection if still available
                if (roleSelect && currentValue && allRoles.find(r => r.id === currentValue)) {
                    roleSelect.value = currentValue;
                    // Don't trigger change, just update display
                    updateRoleInfo();
                    filterAndSortTimers();
                } else {
                    // Clear selection and hide form/table
                    selectedRoleId = null;
                    const addEntryFormEl = document.getElementById('addEntryForm');
                    const tableControlsEl = document.getElementById('tableControls');
                    const roleInfoEl = document.getElementById('roleInfo');
                    
                    if (addEntryFormEl) addEntryFormEl.style.display = 'none';
                    if (tableControlsEl) tableControlsEl.style.display = 'none';
                    if (roleInfoEl) roleInfoEl.textContent = '';
                }
                
                console.log('[Dashboard] Updating reports table...');
                console.log('[Dashboard] data.reports content:', data.reports);
                updateReportsTable(data.reports || []);
                console.log('[Dashboard] Updating autopurge table...');
                console.log('[Dashboard] data.autopurge content:', data.autopurge);
                updateAutopurgeTable(data.autopurge || []);

                console.log('[Dashboard] Populating tabbed view...');
                // Populate tabbed view as well
                populateRoleFilterTab();
                updateTimersTableTab(allTimers);
                console.log('[Dashboard] Calling updateReportsTableTab with:', data.reports);
                updateReportsTableTab(data.reports || []);
                console.log('[Dashboard] Calling updateAutopurgeTableTab with:', data.autopurge);
                updateAutopurgeTableTab(data.autopurge || []);

                console.log('[Dashboard] Updating lastUpdate...');
                const lastUpdateEl = document.getElementById('lastUpdate');
                if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
                console.log('[Dashboard] ========== updateDashboard() COMPLETED SUCCESSFULLY ==========');
                
            } catch (err) {
                console.error('[Dashboard] ERROR INSIDE updateDashboard():', err);
                console.error('[Dashboard] Error message:', err.message);
                console.error('[Dashboard] Error stack:', err.stack);
                // Don't rethrow - we've already logged it
            }
        }

        function onHeaderRoleSelected() {
            // Get the selected role from header dropdown
            selectedRoleId = document.getElementById('headerRoleFilter').value;
            console.log('[onHeaderRoleSelected] Selected role ID:', selectedRoleId, 'allTimers count:', allTimers.length);
            
            if (!selectedRoleId) {
                // Clear all views when no role is selected
                document.getElementById('addEntryForm').style.display = 'none';
                document.getElementById('tableControls').style.display = 'none';
                document.getElementById('timersList').innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üëÜ</div>
                        <p>Select a role above to view timers</p>
                    </div>
                `;
                
                // Clear tabbed view
                document.getElementById('addTimerSectionTab').style.display = 'none';
                document.getElementById('timersTableTab').innerHTML = '';
                return;
            }
            
            // Show forms in both views
            document.getElementById('addEntryForm').style.display = 'block';
            document.getElementById('tableControls').style.display = 'block';
            document.getElementById('addTimerSectionTab').style.display = 'block';
            
            // Update both views
            console.log('[onHeaderRoleSelected] Calling updateRoleInfo and filtering timers');
            updateRoleInfo();
            filterAndSortTimers();
            filterAndSortTimersTab();
        }

        function onRoleSelected() {
            selectedRoleId = document.getElementById('roleFilter').value;
            
            if (!selectedRoleId) {
                document.getElementById('addEntryForm').style.display = 'none';
                document.getElementById('tableControls').style.display = 'none';
                document.getElementById('timersList').innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üëÜ</div>
                        <p>Select a role above to view timers</p>
                    </div>
                `;
                return;
            }
            
            // Show form and controls
            document.getElementById('addEntryForm').style.display = 'block';
            document.getElementById('tableControls').style.display = 'block';
            
            // Pre-fill the role in the add form (set hidden value or show it)
            // Actually, we'll let them select users from the filtered role
            
            updateRoleInfo();
            filterAndSortTimers();
        }

        function updateRoleInfo() {
            if (!selectedRoleId) return;
            
            const role = allRoles.find(r => r.id === selectedRoleId);
            const timerCount = allTimers.filter(t => t.roleId === selectedRoleId).length;
            
            const infoEl = document.getElementById('roleInfo');
            if (infoEl) {
                infoEl.textContent = `${timerCount} timer${timerCount !== 1 ? 's' : ''} active`;
            }
        }

        function filterAndSortTimers() {
            if (!selectedRoleId) {
                console.log('[filterAndSortTimers] No role selected, clearing');
                filteredTimers = [];
                return;
            }
            
            // Filter by role
            let filtered = allTimers.filter(t => t.roleId === selectedRoleId);
            console.log('[filterAndSortTimers] Filtered timers for role', selectedRoleId, ':', filtered.length, 'of', allTimers.length);
            
            // Filter by status
            const statusFilter = document.getElementById('statusFilter')?.value || '';
            if (statusFilter === 'active') {
                filtered = filtered.filter(t => !t.paused && t.remaining > 0);
            } else if (statusFilter === 'paused') {
                filtered = filtered.filter(t => t.paused);
            } else if (statusFilter === 'expired') {
                filtered = filtered.filter(t => t.remaining <= 0);
            }
            
            // Filter by user search
            const userSearch = document.getElementById('userSearch')?.value.toLowerCase() || '';
            if (userSearch) {
                filtered = filtered.filter(t => t.user.toLowerCase().includes(userSearch));
            }
            
            // Sort
            const sortBy = document.getElementById('sortBy')?.value || 'expires-asc';
            
            switch(sortBy) {
                case 'expires-asc':
                    filtered.sort((a, b) => a.expiresAt - b.expiresAt);
                    break;
                case 'expires-desc':
                    filtered.sort((a, b) => b.expiresAt - a.expiresAt);
                    break;
                case 'user-asc':
                    filtered.sort((a, b) => a.user.localeCompare(b.user));
                    break;
                case 'user-desc':
                    filtered.sort((a, b) => b.user.localeCompare(a.user));
                    break;
            }
            
            filteredTimers = filtered;
            updateTimersTable(filteredTimers);
            updateRoleInfo();
        }

        function updateTimersTable(timers) {
            const container = document.getElementById('timersList');
            
            if (timers.length === 0) {
                container.classList.add('placeholder-state');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚è∞</div>
                        <p>No timers match your filters</p>
                    </div>
                `;
                return;
            }
            
            // Remove placeholder styling when displaying table
            container.classList.remove('placeholder-state');

            let html = `
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>User</th>
                                <th>Time Remaining</th>
                                <th>Expires</th>
                                <th>Status</th>
                                <th style="text-align: right;">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            timers.forEach(timer => {
                const badge = timer.paused ? 'badge-paused' : timer.remaining <= 0 ? 'badge-expired' : 'badge-active';
                const status = timer.paused ? '‚è∏Ô∏è PAUSED' : timer.remaining <= 0 ? 'üî¥ EXPIRED' : 'üü¢ ACTIVE';
                
                // Presence indicator
                const presenceEmoji = {
                  'online': 'üü¢',
                  'idle': 'üü°',
                  'dnd': 'üî¥',
                  'offline': '‚ö´'
                }[timer.presence] || '‚ö´';
                
                // Build user display with display name and presence
                const userDisplay = timer.displayName !== timer.user 
                  ? `${timer.user} (${timer.displayName})`
                  : timer.user;
                
                html += `
                    <tr>
                        <td title="${userDisplay}">${presenceEmoji} ${userDisplay}</td>
                        <td class="editable-cell" onclick="editTime(${timer.id})" title="Click to edit">
                            ${timer.formattedTime} ‚úèÔ∏è
                        </td>
                        <td>${new Date(timer.expiresAt).toLocaleString()}</td>
                        <td><span class="badge ${badge}">${status}</span></td>
                        <td class="action-column">
                            <div class="action-buttons">
                                <button class="delete-btn" onclick="deleteTimer(${timer.id}, event)" data-user="${timer.user}" data-role="${timer.role}">‚úï</button>
                            </div>
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        function editTime(timerId, currentTime) {
            // Find the timer and calculate minutes
            const timer = allTimers.find(t => t.id === timerId);
            if (!timer) {
                console.error('Timer not found:', timerId);
                showAlert('Error: Timer not found', 'error');
                return;
            }
            
            // Calculate minutes from remaining milliseconds
            const minutes = Math.ceil(timer.remaining / 60000);
            console.log(`[Edit] Timer ${timerId}: remaining=${timer.remaining}ms, minutes=${minutes}`);
            
            if (minutes < 1 || isNaN(minutes)) {
                showAlert('Invalid timer data', 'error');
                return;
            }
            
            // Find and replace the editable cell
            const cell = event.currentTarget;
            if (!cell) {
                console.error('Could not find cell element');
                return;
            }
            
            // Replace cell content with editable input
            cell.innerHTML = `
                <div style="display: flex; flex-direction: column; gap: 4px;">
                    <input type="text" class="edit-input-field" id="edit-input-${timerId}" value="${minutes}" style="width: 100%; padding: 8px; border: 2px solid #667eea; border-radius: 4px; font-size: 14px;">
                    <div style="display: flex; gap: 4px;">
                        <button class="save-edit-btn" onclick="saveTime(${timerId})">‚úì Save</button>
                        <button class="cancel-edit-btn" onclick="cancelEdit(${timerId})">‚úï Cancel</button>
                    </div>
                </div>
            `;
            
            // Focus and select the input
            const input = document.getElementById(`edit-input-${timerId}`);
            if (input) {
                setTimeout(() => {
                    input.focus();
                    input.select();
                }, 0);
            }
        }

        async function saveTime(timerId) {
            const input = document.getElementById(`edit-input-${timerId}`);
            if (!input) {
                showAlert('Error: Input field not found', 'error');
                return;
            }
            
            const value = input.value.trim();
            const minutes = parseInt(value);

            // Validation
            if (!value || isNaN(minutes)) {
                showAlert('Please enter a valid number of minutes', 'error');
                return;
            }
            
            if (minutes <= 0) {
                showAlert('Minutes must be greater than 0', 'error');
                return;
            }

            console.log(`[Save] Updating timer ${timerId} to ${minutes} minutes`);

            try {
                const response = await fetch(`/api/timer/update?guildId=${guildId}`, {
                    method: 'PATCH',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timerId, minutes })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to update timer');
                }

                const result = await response.json();
                console.log('[Save] Update successful:', result);
                showAlert('Timer updated successfully!', 'success');
                loadDashboard();
            } catch (err) {
                console.error('Error saving time:', err);
                showAlert(`Error: ${err.message}`, 'error');
                loadDashboard();
            }
        }

        function cancelEdit(timerId) {
            loadDashboard();
        }

        function deleteTimer(timerId, event) {
            // Get the button element to extract data attributes
            addDebugLog(`üî¥ deleteTimer called with timerId: ${timerId}`, 'info');
            addDebugLog(`Event object type: ${event?.type || 'undefined'}`, 'info');
            
            const button = event.currentTarget || event.target;
            addDebugLog(`Button element: ${button ? button.tagName : 'null'}`, 'info');
            
            if (!button) {
                addDebugLog('ERROR: Button element not found!', 'error');
                return;
            }
            
            const userName = button.getAttribute('data-user') || 'Unknown User';
            const roleName = button.getAttribute('data-role') || 'Unknown Role';
            
            addDebugLog(`Attempting to delete timer for ${userName} (role: ${roleName})`, 'info');
            
            pendingDeleteId = timerId;
            addDebugLog(`Set pendingDeleteId to: ${pendingDeleteId}`, 'success');
            
            const confirmMsg = `Are you sure you want to delete the timer for ${userName} with role ${roleName}?`;
            addDebugLog(`Setting modal message: ${confirmMsg}`, 'info');
            
            const confirmMsgEl = document.getElementById('confirmMessage');
            if (confirmMsgEl) confirmMsgEl.textContent = confirmMsg;
            const modal = document.getElementById('confirmModal');
            addDebugLog(`Modal element found: ${modal ? 'yes' : 'no'}`, 'info');
            
            if (modal) {
                modal.classList.add('active');
                addDebugLog('‚úÖ Modal shown (active class added)', 'success');
            } else {
                addDebugLog('ERROR: Modal element not found!', 'error');
            }
        }

        async function confirmDelete() {
            addDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
            addDebugLog('üóëÔ∏è confirmDelete() STARTED', 'info');
            addDebugLog(`pendingDeleteId: ${pendingDeleteId}`, 'info');
            addDebugLog(`guildId: ${guildId}`, 'info');
            
            if (!pendingDeleteId) {
                addDebugLog('‚ùå ABORT: No pendingDeleteId set', 'error');
                return;
            }

            addDebugLog(`Confirming deletion of timer ${pendingDeleteId}`, 'info');

            try {
                // Ensure guildId is set
                if (!guildId) {
                    addDebugLog('guildId not set, calling getGuildId()', 'warn');
                    guildId = getGuildId();
                    addDebugLog(`Retrieved guildId: ${guildId}`, 'info');
                }

                if (!guildId) {
                    addDebugLog('‚ùå Guild ID still not available - ABORTING', 'error');
                    throw new Error('Guild ID not available');
                }

                const url = `/api/timer/delete?guildId=${guildId}`;
                addDebugLog(`üì§ Constructed URL: ${url}`, 'info');
                
                const requestBody = { timerId: pendingDeleteId };
                addDebugLog(`üì¶ Request body: ${JSON.stringify(requestBody)}`, 'info');

                addDebugLog('üì° Sending DELETE request...', 'info');
                const response = await fetch(url, {
                    method: 'DELETE',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                addDebugLog(`üì• Response received - Status: ${response.status}`, 'info');
                addDebugLog(`Content-Type: ${response.headers.get('content-type')}, Content-Length: ${response.headers.get('content-length')}`, 'info');

                if (!response.ok) {
                    addDebugLog(`‚ùå Response not OK (${response.status})`, 'error');
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        addDebugLog(`‚ö†Ô∏è Could not parse error response as JSON: ${e.message}`, 'warn');
                        errorData = { error: response.statusText };
                    }
                    addDebugLog(`Error data: ${JSON.stringify(errorData)}`, 'error');
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }

                const result = await response.json();
                addDebugLog(`‚úÖ SUCCESS! Response: ${JSON.stringify(result)}`, 'success');
                showAlert('Timer deleted successfully!', 'success');
                cancelDelete();
                addDebugLog('Calling loadDashboard() to refresh...', 'info');
                await loadDashboard();
                addDebugLog('Dashboard refreshed', 'success');
            } catch (err) {
                addDebugLog(`‚ùå ERROR: ${err.message}`, 'error');
                addDebugLog(`Stack: ${err.stack}`, 'error');
                showAlert(`Error: ${err.message}`, 'error');
                cancelDelete();
            }
            addDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
        }

        function cancelDelete() {
            pendingDeleteId = null;
            document.getElementById('confirmModal').classList.remove('active');
        }

        async function addNewTimer() {
            const userId = document.getElementById('newUser').value.trim();
            const minutes = parseInt(document.getElementById('newMinutes').value);
            const roleId = selectedRoleId; // Use the selected role from dropdown
            const channelId = document.getElementById('newChannel').value.trim() || null;

            if (!userId || !minutes || !roleId) {
                showAlert('Please fill in all required fields', 'error');
                return;
            }

            if (minutes <= 0) {
                showAlert('Minutes must be greater than 0', 'error');
                return;
            }

            try {
                const response = await fetch(`/api/timer/add?guildId=${guildId}`, {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId, minutes, roleId, channelId })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to add timer');
                }

                showAlert('Timer added successfully!', 'success');
                const newUserEl = document.getElementById('newUser');
                const newMinutesEl = document.getElementById('newMinutes');
                const newChannelEl = document.getElementById('newChannel');
                
                if (newUserEl) newUserEl.value = '';
                if (newMinutesEl) newMinutesEl.value = '';
                if (newChannelEl) newChannelEl.value = '';
                loadDashboard();
            } catch (err) {
                console.error('Error adding timer:', err);
                showAlert(`Error: ${err.message}`, 'error');
            }
        }

        // Grid View: Update Reports Table
        function updateReportsTable(reports) {
            const tbody = document.getElementById('reportsTableBody');
            console.log('[updateReportsTable] Called with:', reports?.length || 0, 'items');
            
            if (!reports || reports.length === 0) {
                console.log('[updateReportsTable] No reports, showing empty state');
                tbody.innerHTML = `
                    <tr>
                        <td colspan="5" style="text-align: center; padding: 40px; color: #999;">
                            <div class="empty-state-icon">üìã</div>
                            <p>No scheduled reports yet</p>
                        </td>
                    </tr>
                `;
                return;
            }

            console.log('[updateReportsTable] Rendering', reports.length, 'reports');
            tbody.innerHTML = reports.map((report, idx) => {
                console.log(`  [Report ${idx}]:`, report);
                const lastReport = report.lastReport ? new Date(report.lastReport).toLocaleString() : 'Never';
                const roleDisplay = report.role || report.roleName || 'Unknown';
                const channelDisplay = report.channel || report.channelName || 'Unknown';
                
                return `
                    <tr>
                        <td>${roleDisplay}</td>
                        <td>${channelDisplay}</td>
                        <td class="editable-cell" onclick="editReportInterval(${report.id}, ${report.interval})" title="Click to edit">
                            ${report.interval} min
                        </td>
                        <td>${lastReport}</td>
                        <td class="action-column">
                            <div class="action-buttons">
                                <button class="delete-btn" onclick="deleteReport(${report.id})" title="Delete Report">üóëÔ∏è</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        // Tabbed View: Update Reports Table
        function updateReportsTableTab(reports) {
            const tbody = document.getElementById('reportsTableBodyTab');
            console.log('[updateReportsTableTab] Called with:', reports?.length || 0, 'items');
            
            if (!reports || reports.length === 0) {
                console.log('[updateReportsTableTab] No reports, showing empty state');
                tbody.innerHTML = '<tr><td colspan="5" class="placeholder-state">No scheduled reports yet</td></tr>';
                return;
            }

            console.log('[updateReportsTableTab] Rendering', reports.length, 'reports');
            tbody.innerHTML = reports.map((report, idx) => {
                console.log(`  [Report ${idx}]:`, report);
                const lastReport = report.lastReport ? new Date(report.lastReport).toLocaleString() : 'Never';
                const roleDisplay = report.role || report.roleName || 'Unknown';
                const channelDisplay = report.channel || report.channelName || 'Unknown';
                
                return `
                    <tr>
                        <td>${roleDisplay}</td>
                        <td>${channelDisplay}</td>
                        <td class="editable-cell" onclick="editReportInterval(${report.id}, ${report.interval})" title="Click to edit">
                            ${report.interval} min
                        </td>
                        <td>${lastReport}</td>
                        <td class="action-column">
                            <div class="action-buttons">
                                <button class="delete-btn" onclick="deleteReport(${report.id})" title="Delete Report">üóëÔ∏è</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        async function loadReports() {
            try {
                const response = await fetch(`/api/reports?guildId=${guildId}`, {
                    credentials: 'include'
                });

                if (!response.ok) {
                    console.warn('Failed to load reports:', response.status);
                    return;
                }

                const data = await response.json();
                
                if (data.reports && data.reports.length > 0) {
                    // Resolve role and channel names
                    const allRoles = Array.from(document.querySelectorAll('#reportRole option')).map(opt => ({ id: opt.value, name: opt.text }));
                    const allChannels = Array.from(document.querySelectorAll('#reportChannel option')).map(opt => ({ id: opt.value, name: opt.text }));
                    
                    const formattedReports = data.reports.map(report => {
                        const role = allRoles.find(r => r.id === report.role_id);
                        const channel = allChannels.find(c => c.id === report.channel_id);
                        
                        const lastReport = report.last_report_at 
                            ? new Date(report.last_report_at).toLocaleString()
                            : 'Never';
                        
                        const nextReportMs = report.last_report_at 
                            ? new Date(report.last_report_at).getTime() + (report.interval_minutes * 60 * 1000)
                            : Date.now() + (report.interval_minutes * 60 * 1000);
                        
                        const nextReport = new Date(nextReportMs).toLocaleString();
                        
                        return {
                            id: report.id,
                            role: role?.name || `Unknown (${report.role_id})`,
                            roleId: report.role_id,
                            channel: channel?.name || `Unknown (${report.channel_id})`,
                            channelId: report.channel_id,
                            interval: report.interval_minutes,
                            lastReport: lastReport,
                            nextReport: nextReport
                        };
                    });
                    
                    updateReportsTable(formattedReports);
                    console.log(`[Reports] Loaded ${formattedReports.length} scheduled reports`);
                } else {
                    updateReportsTable([]);
                }
            } catch (err) {
                console.error('Error loading reports:', err);
                updateReportsTable([]);
            }
        }

        // Grid View: Handle Add Report Form Submission
        async function handleAddReport(event) {
            event.preventDefault();
            const roleId = document.getElementById('reportRole').value.trim();
            const channelId = document.getElementById('reportChannel').value.trim();
            const intervalMinutes = parseInt(document.getElementById('reportInterval').value);

            if (!roleId || !channelId || !intervalMinutes) {
                showAlert('Please fill in all required fields', 'error');
                return false;
            }

            if (intervalMinutes <= 0) {
                showAlert('Interval must be greater than 0', 'error');
                return false;
            }

            try {
                const response = await fetch(`/api/report/add?guildId=${guildId}`, {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roleId, channelId, intervalMinutes })
                });

                if (!response.ok) {
                    const error = await response.json();
                    let message = error.error || 'Failed to add report';
                    
                    // Improve 409 Conflict messages
                    if (response.status === 409) {
                        message = 'A scheduled report already exists for this role and channel combination. You can update or delete the existing one instead.';
                    }
                    throw new Error(message);
                }

                showAlert('Scheduled report added successfully!', 'success');
                document.getElementById('addReportForm').reset();
                loadDashboard();
            } catch (err) {
                console.error('Error adding report:', err);
                showAlert(`Error: ${err.message}`, 'error');
            }
            return false;
        }

        // Tabbed View: Handle Add Report Form Submission
        async function handleAddReportTab(event) {
            event.preventDefault();
            const roleId = document.getElementById('reportRoleTab').value.trim();
            const channelId = document.getElementById('reportChannelTab').value.trim();
            const intervalMinutes = parseInt(document.getElementById('reportIntervalTab').value);

            if (!roleId || !channelId || !intervalMinutes) {
                showAlert('Please fill in all required fields', 'error');
                return false;
            }

            if (intervalMinutes <= 0) {
                showAlert('Interval must be greater than 0', 'error');
                return false;
            }

            try {
                const response = await fetch(`/api/report/add?guildId=${guildId}`, {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roleId, channelId, intervalMinutes })
                });

                if (!response.ok) {
                    const error = await response.json();
                    let message = error.error || 'Failed to add report';
                    
                    // Improve 409 Conflict messages
                    if (response.status === 409) {
                        message = 'A scheduled report already exists for this role and channel combination. You can update or delete the existing one instead.';
                    }
                    throw new Error(message);
                }

                showAlert('Scheduled report added successfully!', 'success');
                document.getElementById('addReportFormTab').reset();
                loadDashboard();
            } catch (err) {
                console.error('Error adding report:', err);
                showAlert(`Error: ${err.message}`, 'error');
            }
            return false;
        }

        function editReportInterval(reportId, currentInterval) {
            const newInterval = prompt(`Enter new interval (minutes):\nCurrent: ${currentInterval} minutes`, currentInterval);
            
            if (newInterval === null) return;
            
            const interval = parseInt(newInterval);
            if (isNaN(interval) || interval <= 0) {
                showAlert('Interval must be a positive number', 'error');
                return;
            }

            updateReportInterval(reportId, interval);
        }

        async function updateReportInterval(reportId, intervalMinutes) {
            try {
                const response = await fetch(`/api/report/update?guildId=${guildId}`, {
                    method: 'PATCH',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ reportId, intervalMinutes })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to update report');
                }

                showAlert('Scheduled report updated successfully!', 'success');
                loadDashboard();
            } catch (err) {
                console.error('Error updating report:', err);
                showAlert(`Error: ${err.message}`, 'error');
            }
        }

        // Grid View: Update Autopurge Table
        function updateAutopurgeTable(autopurge) {
            const tbody = document.getElementById('autopurgeTableBody');
            console.log('[updateAutopurgeTable] Called with:', autopurge?.length || 0, 'items');
            
            if (!autopurge || autopurge.length === 0) {
                console.log('[updateAutopurgeTable] No autopurge settings, showing empty state');
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" style="text-align: center; padding: 40px; color: #999;">
                            <div class="empty-state-icon">üóëÔ∏è</div>
                            <p>No auto-purge settings configured</p>
                        </td>
                    </tr>
                `;
                return;
            }
            console.log('[updateAutopurgeTable] Rendering', autopurge.length, 'autopurge settings');

            tbody.innerHTML = autopurge.map((setting, idx) => {
                console.log(`  [Autopurge ${idx}]:`, setting);
                const typeMap = {
                    'all': 'All Messages',
                    'bots': 'Bot Messages',
                    'embeds': 'Embeds Only'
                };
                const typeDisplay = typeMap[setting.type] || setting.type;
                const lastPurge = setting.lastPurge ? new Date(setting.lastPurge).toLocaleString() : 'Never';
                const channelDisplay = setting.channel || setting.channelName || 'Unknown';
                
                return `
                    <tr>
                        <td>${channelDisplay}</td>
                        <td>${typeDisplay}</td>
                        <td class="editable-cell" onclick="editAutopurgeSetting('${setting.channelId}', 'lines', ${setting.lines})">
                            ${setting.lines}
                        </td>
                        <td class="editable-cell" onclick="editAutopurgeSetting('${setting.channelId}', 'interval', ${setting.interval})">
                            ${setting.interval} min
                        </td>
                        <td>${lastPurge}</td>
                        <td class="action-column">
                            <div class="action-buttons">
                                <button class="delete-btn" onclick="deleteAutopurgeSetting('${setting.channelId}')" title="Delete Setting">üóëÔ∏è</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        // Tabbed View: Update Autopurge Table
        function updateAutopurgeTableTab(autopurge) {
            const tbody = document.getElementById('autopurgeTableBodyTab');
            console.log('[updateAutopurgeTableTab] Called with:', autopurge?.length || 0, 'items');
            
            if (!autopurge || autopurge.length === 0) {
                console.log('[updateAutopurgeTableTab] No autopurge settings, showing empty state');
                tbody.innerHTML = '<tr><td colspan="6" class="placeholder-state">No auto-purge settings yet</td></tr>';
                return;
            }

            console.log('[updateAutopurgeTableTab] Rendering', autopurge.length, 'autopurge settings');

            tbody.innerHTML = autopurge.map((setting, idx) => {
                console.log(`  [Autopurge ${idx}]:`, setting);
                const typeMap = {
                    'all': 'All Messages',
                    'bots': 'Bot Messages',
                    'embeds': 'Embeds Only'
                };
                const typeDisplay = typeMap[setting.type] || setting.type;
                const lastPurge = setting.lastPurge ? new Date(setting.lastPurge).toLocaleString() : 'Never';
                const channelDisplay = setting.channel || setting.channelName || 'Unknown';
                
                return `
                    <tr>
                        <td>${channelDisplay}</td>
                        <td>${typeDisplay}</td>
                        <td>${setting.lines}</td>
                        <td>${setting.interval} min</td>
                        <td>${lastPurge}</td>
                        <td class="action-column">
                            <div class="action-buttons">
                                <button class="delete-btn" onclick="deleteAutopurgeSetting('${setting.channelId}')" title="Delete Setting">üóëÔ∏è</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        async function loadAutopurge() {
            try {
                const response = await fetch(`/api/dashboard?guildId=${guildId}`, {
                    credentials: 'include'
                });

                if (!response.ok) {
                    throw new Error('Failed to load autopurge settings');
                }

                const data = await response.json();
                updateAutopurgeTable(data.autopurge || []);
            } catch (err) {
                console.error('Error loading autopurge settings:', err);
                showAlert(`Error: ${err.message}`, 'error');
            }
        }

        // Grid View: Handle Add Autopurge Form Submission
        async function handleAddAutopurge(event) {
            event.preventDefault();
            const channelId = document.getElementById('autopurgeChannel').value.trim();
            const type = document.getElementById('autopurgeType').value.trim();
            const lines = parseInt(document.getElementById('autopurgeLines').value);
            const intervalMinutes = parseInt(document.getElementById('autopurgeInterval').value);

            if (!channelId || !type || !lines || !intervalMinutes) {
                showAlert('Please fill in all required fields', 'error');
                return false;
            }

            if (lines <= 0 || intervalMinutes <= 0) {
                showAlert('Lines and interval must be positive numbers', 'error');
                return false;
            }

            try {
                const response = await fetch(`/api/autopurge/add?guildId=${guildId}`, {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channelId,
                        type,
                        lines,
                        intervalMinutes
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    let message = error.error || 'Failed to add autopurge setting';
                    
                    // Improve 409 Conflict messages
                    if (response.status === 409) {
                        message = 'This channel already has an auto-purge setting. You can update or delete the existing one instead.';
                    }
                    throw new Error(message);
                }

                showAlert('Auto-purge setting added successfully!', 'success');
                document.getElementById('addAutopurgeForm').reset();
                loadDashboard();
            } catch (err) {
                console.error('Error adding autopurge setting:', err);
                showAlert(`Error: ${err.message}`, 'error');
            }
            return false;
        }

        // Tabbed View: Handle Add Autopurge Form Submission
        async function handleAddAutopurgeTab(event) {
            event.preventDefault();
            const channelId = document.getElementById('autopurgeChannelTab').value.trim();
            const type = document.getElementById('autopurgeTypeTab').value.trim();
            const lines = parseInt(document.getElementById('autopurgeLinesTab').value);
            const intervalMinutes = parseInt(document.getElementById('autopurgeIntervalTab').value);

            if (!channelId || !type || !lines || !intervalMinutes) {
                showAlert('Please fill in all required fields', 'error');
                return false;
            }

            if (lines <= 0 || intervalMinutes <= 0) {
                showAlert('Lines and interval must be positive numbers', 'error');
                return false;
            }

            try {
                const response = await fetch(`/api/autopurge/add?guildId=${guildId}`, {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channelId,
                        type,
                        lines,
                        intervalMinutes
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    let message = error.error || 'Failed to add autopurge setting';
                    
                    // Improve 409 Conflict messages
                    if (response.status === 409) {
                        message = 'This channel already has an auto-purge setting. You can update or delete the existing one instead.';
                    }
                    throw new Error(message);
                }

                showAlert('Auto-purge setting added successfully!', 'success');
                document.getElementById('autopurgeFormTab').reset();
                loadDashboard();
            } catch (err) {
                console.error('Error adding autopurge setting:', err);
                showAlert(`Error: ${err.message}`, 'error');
            }
            return false;
        }

        function editAutopurgeSetting(channelId, field, currentValue) {
            const fieldName = field === 'lines' ? 'Messages to Purge' : 'Interval (minutes)';
            const newValue = prompt(`Edit ${fieldName}:\nCurrent value: ${currentValue}`, currentValue);
            
            if (newValue === null) return;
            
            const parsedValue = parseInt(newValue);
            if (isNaN(parsedValue) || parsedValue <= 0) {
                showAlert(`Please enter a valid positive number`, 'error');
                return;
            }

            updateAutopurgeSetting(channelId, field, parsedValue);
        }

        async function updateAutopurgeSetting(channelId, field, newValue) {
            try {
                const updateData = field === 'lines' 
                    ? { lines: newValue }
                    : { intervalMinutes: newValue };

                const response = await fetch(`/api/autopurge/update?guildId=${guildId}`, {
                    method: 'PATCH',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channelId,
                        ...updateData
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to update autopurge setting');
                }

                showAlert(`Auto-purge setting updated successfully!`, 'success');
                loadDashboard();
            } catch (err) {
                console.error('Error updating autopurge setting:', err);
                showAlert(`Error: ${err.message}`, 'error');
            }
        }

        /**
         * Load dropdown data (users, roles, channels) for the add entry form
         */
        async function loadDropdownData() {
            try {
                const response = await fetch(`/api/dropdown-data?guildId=${guildId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    console.warn('Failed to load dropdown data:', response.status);
                    // Don't show error - form will still work with manual IDs
                    return;
                }
                
                const data = await response.json();
                
                // Store users in global array for searchable dropdown
                if (data.users && data.users.length > 0) {
                    // Deduplicate by user ID (just in case)
                    const userMap = new Map();
                    data.users.forEach(user => {
                        if (!userMap.has(user.id)) {
                            userMap.set(user.id, user);
                        }
                    });
                    
                    allUsers = Array.from(userMap.values()).sort((a, b) => {
                        const aName = (a.displayName || a.name || '').toLowerCase();
                        const bName = (b.displayName || b.name || '').toLowerCase();
                        return aName.localeCompare(bName);
                    });
                    console.log(`[Searchable Dropdown] Loaded ${allUsers.length} unique users (deduped from ${data.users.length})`);
                } else {
                    allUsers = [];
                    console.warn('[Searchable Dropdown] No users found');
                }
                
                // Populate Role dropdown - Clear old options first (keeping placeholder)
                const roleSelect = document.getElementById('newRole');
                if (roleSelect) {
                    // Remove all options except the placeholder
                    while (roleSelect.options.length > 1) {
                        roleSelect.remove(1);
                    }
                    // Add new options if data available
                    if (data.roles && data.roles.length > 0) {
                        data.roles.forEach(role => {
                            const option = document.createElement('option');
                            option.value = role.id;
                            option.textContent = role.name;
                            roleSelect.appendChild(option);
                        });
                    }
                }
                
                // Populate Channel dropdown - Clear old options first (keeping placeholder)
                const channelSelect = document.getElementById('newChannel');
                if (channelSelect) {
                    // Remove all options except the placeholder
                    while (channelSelect.options.length > 1) {
                        channelSelect.remove(1);
                    }
                    // Add new options if data available
                    if (data.channels && data.channels.length > 0) {
                        data.channels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.id;
                            option.textContent = '#' + channel.name;
                            channelSelect.appendChild(option);
                        });
                    }
                }
                
                // Populate HEADER Role Filter Dropdown - works for both grid and tabbed views
                const headerRoleSelect = document.getElementById('headerRoleFilter');
                if (headerRoleSelect) {
                    // Remove all options except the placeholder
                    while (headerRoleSelect.options.length > 1) {
                        headerRoleSelect.remove(1);
                    }
                    // Add new options if data available
                    if (data.roles && data.roles.length > 0) {
                        data.roles.forEach(role => {
                            const option = document.createElement('option');
                            option.value = role.id;
                            option.textContent = role.name;
                            headerRoleSelect.appendChild(option);
                        });
                    }
                }
                
                // Also populate the report dropdowns (reportRole and reportChannel)
                const reportRoleSelect = document.getElementById('reportRole');
                if (reportRoleSelect) {
                    // Remove all options except the placeholder
                    while (reportRoleSelect.options.length > 1) {
                        reportRoleSelect.remove(1);
                    }
                    // Add new options if data available
                    if (data.roles && data.roles.length > 0) {
                        data.roles.forEach(role => {
                            const option = document.createElement('option');
                            option.value = role.id;
                            option.textContent = role.name;
                            reportRoleSelect.appendChild(option);
                        });
                    }
                }
                
                const reportChannelSelect = document.getElementById('reportChannel');
                if (reportChannelSelect) {
                    // Remove all options except the placeholder
                    while (reportChannelSelect.options.length > 1) {
                        reportChannelSelect.remove(1);
                    }
                    // Add new options if data available
                    if (data.channels && data.channels.length > 0) {
                        data.channels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.id;
                            option.textContent = '#' + channel.name;
                            reportChannelSelect.appendChild(option);
                        });
                    }
                }

                // Populate autopurge channel dropdown
                const autopurgeChannelSelect = document.getElementById('autopurgeChannel');
                if (autopurgeChannelSelect) {
                    // Remove all options except the placeholder
                    while (autopurgeChannelSelect.options.length > 1) {
                        autopurgeChannelSelect.remove(1);
                    }
                    // Add new options if data available
                    if (data.channels && data.channels.length > 0) {
                        data.channels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.id;
                            option.textContent = '#' + channel.name;
                            autopurgeChannelSelect.appendChild(option);
                        });
                    }
                }

                // Populate tabbed view dropdowns
                // Role dropdown for tabbed timer form
                const newRoleTabSelect = document.getElementById('newRoleTab');
                if (newRoleTabSelect) {
                    while (newRoleTabSelect.options.length > 1) {
                        newRoleTabSelect.remove(1);
                    }
                    if (data.roles && data.roles.length > 0) {
                        data.roles.forEach(role => {
                            const option = document.createElement('option');
                            option.value = role.id;
                            option.textContent = role.name;
                            newRoleTabSelect.appendChild(option);
                        });
                    }
                }

                // Channel dropdown for tabbed timer form
                const newChannelTabSelect = document.getElementById('newChannelTab');
                if (newChannelTabSelect) {
                    while (newChannelTabSelect.options.length > 1) {
                        newChannelTabSelect.remove(1);
                    }
                    if (data.channels && data.channels.length > 0) {
                        data.channels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.id;
                            option.textContent = '#' + channel.name;
                            newChannelTabSelect.appendChild(option);
                        });
                    }
                }

                // Role dropdown for tabbed reports form
                const reportRoleTabSelect = document.getElementById('reportRoleTab');
                if (reportRoleTabSelect) {
                    while (reportRoleTabSelect.options.length > 1) {
                        reportRoleTabSelect.remove(1);
                    }
                    if (data.roles && data.roles.length > 0) {
                        data.roles.forEach(role => {
                            const option = document.createElement('option');
                            option.value = role.id;
                            option.textContent = role.name;
                            reportRoleTabSelect.appendChild(option);
                        });
                    }
                }

                // Channel dropdown for tabbed reports form
                const reportChannelTabSelect = document.getElementById('reportChannelTab');
                if (reportChannelTabSelect) {
                    while (reportChannelTabSelect.options.length > 1) {
                        reportChannelTabSelect.remove(1);
                    }
                    if (data.channels && data.channels.length > 0) {
                        data.channels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.id;
                            option.textContent = '#' + channel.name;
                            reportChannelTabSelect.appendChild(option);
                        });
                    }
                }

                // Channel dropdown for tabbed autopurge form
                const autopurgeChannelTabSelect = document.getElementById('autopurgeChannelTab');
                if (autopurgeChannelTabSelect) {
                    while (autopurgeChannelTabSelect.options.length > 1) {
                        autopurgeChannelTabSelect.remove(1);
                    }
                    if (data.channels && data.channels.length > 0) {
                        data.channels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.id;
                            option.textContent = '#' + channel.name;
                            autopurgeChannelTabSelect.appendChild(option);
                        });
                    }
                }
                
                console.log(`[Dropdown] Loaded: ${allUsers.length} users, ${data.roles.length} roles, ${data.channels.length} channels`);
            } catch (err) {
                console.error('Error loading dropdown data:', err);
                // Don't show error - form will still work
            }
        }

        async function loadMemberCount() {
            try {
                const guildId = new URLSearchParams(window.location.search).get('guildId');
                if (!guildId) return;
                
                const response = await fetch(`/api/guild-member-count?guildId=${guildId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) return;
                
                const data = await response.json();
                
                // Display member count badge
                const badge = document.getElementById('memberCountBadge');
                const count = document.getElementById('memberCount');
                
                if (badge && count) {
                    count.textContent = data.memberCount;
                    badge.style.display = 'inline-block';
                    console.log(`[Member Count] ${data.memberCount} members cached for guild ${guildId}`);
                }
            } catch (err) {
                console.error('Error loading member count:', err);
                // Don't show error - UI will still work without count
            }
        }

        async function loadDashboardAndDropdowns() {
            await loadDashboard();
            await loadDropdownData();
            await loadMemberCount();
        }

        // Tabbed View Functions
        function onRoleSelectedTab() {
            const roleFilter = document.getElementById('roleFilter');
            const selectedRole = roleFilter.value;
            const addSection = document.getElementById('addTimerSectionTab');
            const roleInfo = document.getElementById('roleInfoTab');
            
            if (selectedRole) {
                addSection.style.display = 'block';
                const timerCount = allTimers.filter(t => t.role_id === selectedRole).length;
                roleInfo.textContent = `${timerCount} timer(s) for this role`;
                filterTimersByRoleTab(selectedRole);
            } else {
                addSection.style.display = 'none';
                roleInfo.textContent = '';
                updateTimersTableTab(allTimers);
            }
        }

        function filterTimersByRoleTab(roleId) {
            if (!roleId) {
                return allTimers;
            }
            return allTimers.filter(t => t.role_id === roleId);
        }

        function updateTimersTableTab(timers) {
            const tbody = document.getElementById('timersListTab');
            
            if (!timers || timers.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="placeholder-state">No timers yet</td></tr>';
                return;
            }

            tbody.innerHTML = timers.map(timer => {
                const badge = timer.paused ? 'badge-paused' : timer.remaining <= 0 ? 'badge-expired' : 'badge-active';
                const status = timer.paused ? '‚è∏Ô∏è PAUSED' : timer.remaining <= 0 ? 'üî¥ EXPIRED' : 'üü¢ ACTIVE';
                const presenceEmoji = {
                  'online': 'üü¢',
                  'idle': 'üü°',
                  'dnd': 'üî¥',
                  'offline': '‚ö´'
                }[timer.presence] || '‚ö´';
                
                const userDisplay = timer.displayName !== timer.user 
                  ? `${timer.user} (${timer.displayName})`
                  : timer.user;
                
                return `
                    <tr>
                        <td title="${userDisplay}">${presenceEmoji} ${userDisplay}</td>
                        <td>${timer.role}</td>
                        <td class="editable-cell" onclick="editTime(${timer.id})" title="Click to edit">
                            ${timer.formattedTime} ‚úèÔ∏è
                        </td>
                        <td>${new Date(timer.expiresAt).toLocaleString()}</td>
                        <td><span class="badge ${badge}">${status}</span></td>
                        <td class="action-column">
                            <div class="action-buttons">
                                <button class="delete-btn" onclick="deleteTimer(${timer.id}, event)" data-user="${timer.user}" data-role="${timer.role}">‚úï</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function toggleAddTimerFormTab() {
            const form = document.getElementById('addEntryFormTab');
            const icon = document.getElementById('addTimerTabToggleIcon');
            if (form && icon) {
                const isHidden = form.style.display === 'none';
                form.style.display = isHidden ? 'block' : 'none';
                icon.textContent = isHidden ? '‚ûñ' : '‚ûï';
            }
        }

        function filterAndSortTimersTab() {
            if (!selectedRoleId) {
                document.getElementById('timersListTab').innerHTML = '';
                return;
            }
            
            const searchInput = document.getElementById('userSearchTab');
            const statusFilter = document.getElementById('statusFilterTab');
            const sortBy = document.getElementById('sortByTab');
            
            let filtered = allTimers.filter(t => t.roleId === selectedRoleId);
            
            // Filter by search
            if (searchInput && searchInput.value) {
                const query = searchInput.value.toLowerCase();
                filtered = filtered.filter(t => t.user.toLowerCase().includes(query));
            }
            
            // Filter by status
            if (statusFilter && statusFilter.value) {
                const statusVal = statusFilter.value;
                if (statusVal === 'active') {
                    filtered = filtered.filter(t => !t.paused && t.remaining > 0);
                } else if (statusVal === 'paused') {
                    filtered = filtered.filter(t => t.paused);
                } else if (statusVal === 'expired') {
                    filtered = filtered.filter(t => t.remaining <= 0);
                }
            }
            
            // Sort
            if (sortBy) {
                const sort = sortBy.value;
                if (sort === 'expires-asc') {
                    filtered.sort((a, b) => a.expiresAt - b.expiresAt);
                } else if (sort === 'expires-desc') {
                    filtered.sort((a, b) => b.expiresAt - a.expiresAt);
                } else if (sort === 'user-asc') {
                    filtered.sort((a, b) => a.user.localeCompare(b.user));
                } else if (sort === 'user-desc') {
                    filtered.sort((a, b) => b.user.localeCompare(a.user));
                }
            }
            
            updateTimersTableTab(filtered);
        }

        function populateRoleFilterTab() {
            const roleFilter = document.getElementById('roleFilter');
            if (!roleFilter) return;
            
            // Get unique roles from timers
            const roles = [...new Set(allTimers.map(t => ({ id: t.roleId, name: t.role })))];
            
            // Preserve current selection
            const currentValue = roleFilter.value;
            
            // Clear options except placeholder
            while (roleFilter.options.length > 1) {
                roleFilter.remove(1);
            }
            
            // Add role options
            roles.forEach(role => {
                const option = document.createElement('option');
                option.value = role.id;
                option.textContent = role.name;
                roleFilter.appendChild(option);
            });
            
            // Restore selection
            roleFilter.value = currentValue;
        }

        function updateReportsTableTab(reports) {
            const tbody = document.getElementById('reportsTableBodyTab');
            console.log('[updateReportsTableTab] Called with:', reports, 'length:', reports?.length);
            
            if (!reports || reports.length === 0) {
                console.log('[updateReportsTableTab] No reports, showing empty state');
                tbody.innerHTML = '<tr><td colspan="5" class="placeholder-state">No scheduled reports yet</td></tr>';
                return;
            }

            console.log('[updateReportsTableTab] Rendering', reports.length, 'reports');

            tbody.innerHTML = reports.map(report => {
                const lastReport = report.lastReport || 'Never';
                
                return `
                    <tr>
                        <td>${report.role}</td>
                        <td>${report.channel}</td>
                        <td class="editable-cell" onclick="editReportInterval(${report.id}, ${report.interval})" title="Click to edit">
                            ${report.interval} min
                        </td>
                        <td>${lastReport}</td>
                        <td class="action-column">
                            <div class="action-buttons">
                                <button class="delete-btn" onclick="deleteReport(${report.id})" title="Delete Report">üóëÔ∏è</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function updateAutopurgeTableTab(autopurge) {
            const tbody = document.getElementById('autopurgeTableBodyTab');
            console.log('[updateAutopurgeTableTab] Called with:', autopurge, 'length:', autopurge?.length);
            
            if (!autopurge || autopurge.length === 0) {
                console.log('[updateAutopurgeTableTab] No autopurge settings, showing empty state');
                tbody.innerHTML = '<tr><td colspan="6" class="placeholder-state">No auto-purge settings yet</td></tr>';
                return;
            }

            console.log('[updateAutopurgeTableTab] Rendering', autopurge.length, 'autopurge settings');

            tbody.innerHTML = autopurge.map(setting => {
                const lastPurge = setting.lastPurge || 'Never';
                
                return `
                    <tr>
                        <td>${setting.channel}</td>
                        <td>${setting.type}</td>
                        <td>${setting.lines}</td>
                        <td>${setting.interval} min</td>
                        <td>${lastPurge}</td>
                        <td class="action-column">
                            <div class="action-buttons">
                                <button class="delete-btn" onclick="deleteAutopurgeSetting('${setting.channelId}')" title="Delete Setting">üóëÔ∏è</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function handleAddTimerTab(event) {
            event.preventDefault();
            return handleAddTimer(event);
        }

        function handleAddReportTab(event) {
            // This is a stub - the actual implementation is defined earlier
            // It ensures form submission events are properly handled
            if (event) {
                event.preventDefault();
            }
            return false;
        }

        function handleAddAutopurgeTab(event) {
            // This is a stub - the actual implementation is defined earlier
            // It ensures form submission events are properly handled
            if (event) {
                event.preventDefault();
            }
            return false;
        }

        // Fetch and display version dynamically
        async function loadVersion() {
            try {
                const response = await fetch('/api/version');
                if (response.ok) {
                    const versionData = await response.json();
                    const versionDisplayEl = document.getElementById('versionDisplay');
                    if (versionDisplayEl) versionDisplayEl.textContent = versionData.version;
                    const tabVersion = document.getElementById('versionDisplayTab');
                    if (tabVersion) {
                        tabVersion.textContent = versionData.version;
                    }
                    console.log('[Version] Dashboard v' + versionData.version);
                }
            } catch (err) {
                console.warn('[Version] Could not fetch version:', err.message);
                // Version display already has fallback value
            }
        }

        // Load dashboard on page load
        (async () => {
            const isAuth = await checkAuth();
            if (isAuth) {
                loadVersion(); // Load version info
                await loadDashboard(); // Must load FIRST to get guildId
                // Load dropdowns and member count in PARALLEL after guildId is set
                await Promise.all([
                    loadDropdownData(),
                    loadMemberCount()
                ]);
                initSearchableDropdown(); // Initialize the searchable dropdown
                setInterval(loadDashboard, 30000);
                setInterval(loadDropdownData, 60000); // Refresh dropdowns every minute
                setInterval(loadMemberCount, 60 * 60 * 1000); // Refresh member count every hour (matches sync interval)
            }
        })();
    </script>
</body>
</html>
